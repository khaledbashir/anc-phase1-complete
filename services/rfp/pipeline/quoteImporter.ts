/**
 * Step 5: Quote Importer
 *
 * Imports a completed subcontractor quote Excel back into the system.
 * Matches quoted rows back to extracted specs by display name + index.
 * Extracts: unit cost ($/sqft), lead time (weeks), notes/alt model.
 */

import ExcelJS from "exceljs";
import type { ExtractedLEDSpec } from "@/services/rfp/unified/types";

// ─── Types ──────────────────────────────────────────────────────────────────

export interface QuotedSpec {
  /** Index in the original specs array */
  specIndex: number;
  /** Display name (for matching verification) */
  displayName: string;
  /** Subcontractor-provided cost per sqft */
  costPerSqFt: number | null;
  /** Lead time in weeks */
  leadTimeWeeks: number | null;
  /** Subcontractor notes or alternative model */
  notes: string | null;
  /** Whether this row had any response data */
  hasQuote: boolean;
}

export interface QuoteImportResult {
  /** Parsed quotes matched to spec indices */
  quotes: QuotedSpec[];
  /** Source file name */
  filename: string;
  /** How many specs had quotes filled in */
  quotedCount: number;
  /** How many specs were missing quotes */
  missingCount: number;
  /** Warnings (mismatches, parse errors) */
  warnings: string[];
}

// ─── Importer ───────────────────────────────────────────────────────────────

/**
 * Parse a returned subcontractor quote Excel and extract pricing data.
 *
 * Expects the Excel generated by generateSubcontractorExcel — reads from
 * the "Quote Request" sheet, columns K-N (Unit Cost, Lead Time, Notes).
 *
 * Also supports a simpler format: any sheet where column A is a number (index)
 * and there are cost/leadtime/notes columns.
 */
export async function importQuoteExcel(
  buffer: Buffer,
  originalSpecs: ExtractedLEDSpec[],
  filename: string,
): Promise<QuoteImportResult> {
  const workbook = new ExcelJS.Workbook();
  await workbook.xlsx.load(buffer);

  const warnings: string[] = [];
  const quotes: QuotedSpec[] = [];

  // Try "Quote Request" sheet first, then first sheet
  let sheet = workbook.getWorksheet("Quote Request") || workbook.worksheets[0];
  if (!sheet) {
    return {
      quotes: [],
      filename,
      quotedCount: 0,
      missingCount: originalSpecs.length,
      warnings: ["No sheets found in Excel file"],
    };
  }

  // Find the header row — look for "Display Name" or "#" column
  let headerRow = 0;
  let colMap: Record<string, number> = {};

  sheet.eachRow((row, rowNumber) => {
    if (headerRow > 0) return;

    const values: string[] = [];
    row.eachCell((cell) => {
      values.push(String(cell.value || "").toLowerCase().trim());
    });

    const joined = values.join(" ");
    if (joined.includes("display name") || joined.includes("display") && joined.includes("unit cost")) {
      headerRow = rowNumber;

      // Map column positions
      row.eachCell((cell, colNumber) => {
        const val = String(cell.value || "").toLowerCase().trim();
        if (val.includes("#") || val === "#") colMap["index"] = colNumber;
        if (val.includes("display name") || val === "display") colMap["name"] = colNumber;
        if (val.includes("unit cost")) colMap["cost"] = colNumber;
        if (val.includes("lead time")) colMap["leadTime"] = colNumber;
        if (val.includes("notes") || val.includes("alt model")) colMap["notes"] = colNumber;
      });
    }
  });

  if (headerRow === 0) {
    // Fallback: assume our generated format (cols 1-14)
    headerRow = findDataStartRow(sheet);
    colMap = { index: 1, name: 2, cost: 12, leadTime: 13, notes: 14 };
    if (headerRow === 0) {
      return {
        quotes: [],
        filename,
        quotedCount: 0,
        missingCount: originalSpecs.length,
        warnings: ["Could not find header row in Excel. Expected 'Display Name' column."],
      };
    }
  }

  // Parse data rows after header
  const dataStartRow = headerRow + 1;

  for (let rowIdx = dataStartRow; rowIdx <= sheet.rowCount; rowIdx++) {
    const row = sheet.getRow(rowIdx);

    // Read index/name for matching
    const rawIndex = colMap["index"] ? row.getCell(colMap["index"]).value : null;
    const rawName = colMap["name"] ? String(row.getCell(colMap["name"]).value || "").trim() : "";

    // Skip non-data rows (empty, summary, instructions)
    if (!rawName || rawName === "" || rawName === "—") continue;
    if (rawName.toLowerCase().startsWith("total") || rawName.toLowerCase().startsWith("instruction")) break;

    // Determine spec index
    let specIndex = -1;
    if (rawIndex != null && typeof rawIndex === "number") {
      specIndex = rawIndex - 1; // 1-based to 0-based
    } else {
      // Try fuzzy name match
      specIndex = originalSpecs.findIndex(
        (s) => s.name.toLowerCase().trim() === rawName.toLowerCase(),
      );
    }

    if (specIndex < 0 || specIndex >= originalSpecs.length) {
      warnings.push(`Row ${rowIdx}: Could not match "${rawName}" to any extracted spec`);
      continue;
    }

    // Extract subcontractor response
    const rawCost = colMap["cost"] ? row.getCell(colMap["cost"]).value : null;
    const rawLeadTime = colMap["leadTime"] ? row.getCell(colMap["leadTime"]).value : null;
    const rawNotes = colMap["notes"] ? row.getCell(colMap["notes"]).value : null;

    const costPerSqFt = parseNumericCell(rawCost);
    const leadTimeWeeks = parseNumericCell(rawLeadTime);
    const notes = rawNotes ? String(rawNotes).trim() : null;

    const hasQuote = costPerSqFt != null || leadTimeWeeks != null || (notes != null && notes !== "");

    quotes.push({
      specIndex,
      displayName: rawName,
      costPerSqFt,
      leadTimeWeeks,
      notes: notes || null,
      hasQuote,
    });
  }

  // Check for missing specs
  const quotedIndices = new Set(quotes.filter((q) => q.hasQuote).map((q) => q.specIndex));
  const missingSpecs = originalSpecs.filter((_, i) => !quotedIndices.has(i));
  if (missingSpecs.length > 0) {
    warnings.push(
      `Missing quotes for ${missingSpecs.length} display(s): ${missingSpecs.map((s) => s.name).join(", ")}`,
    );
  }

  return {
    quotes,
    filename,
    quotedCount: quotes.filter((q) => q.hasQuote).length,
    missingCount: missingSpecs.length,
    warnings,
  };
}

// ─── Manual quote entry (no Excel needed) ───────────────────────────────────

export interface ManualQuoteEntry {
  specIndex: number;
  costPerSqFt: number;
  leadTimeWeeks?: number;
  notes?: string;
}

export function applyManualQuotes(
  specs: ExtractedLEDSpec[],
  entries: ManualQuoteEntry[],
): QuotedSpec[] {
  return entries.map((entry) => ({
    specIndex: entry.specIndex,
    displayName: specs[entry.specIndex]?.name || `Display ${entry.specIndex + 1}`,
    costPerSqFt: entry.costPerSqFt,
    leadTimeWeeks: entry.leadTimeWeeks ?? null,
    notes: entry.notes ?? null,
    hasQuote: true,
  }));
}

// ─── Helpers ────────────────────────────────────────────────────────────────

function parseNumericCell(value: unknown): number | null {
  if (value == null) return null;
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    // Strip currency symbols, commas
    const cleaned = value.replace(/[$,€£\s]/g, "");
    const num = parseFloat(cleaned);
    return isNaN(num) ? null : num;
  }
  // ExcelJS can return { result: number } for formula cells
  if (typeof value === "object" && "result" in (value as Record<string, unknown>)) {
    return parseNumericCell((value as Record<string, unknown>).result);
  }
  return null;
}

function findDataStartRow(sheet: ExcelJS.Worksheet): number {
  let found = 0;
  sheet.eachRow((row, rowNumber) => {
    if (found > 0) return;
    const cellA = row.getCell(1).value;
    if (cellA === 1 || cellA === "1") {
      found = rowNumber;
    }
  });
  return found > 0 ? found - 1 : 0; // return header row (1 above first data)
}
